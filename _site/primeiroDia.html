<!DOCTYPE html>
<html>
    <head>
        <title>Minicurso de Linux e Git</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="./assets/css/styles.css">
        <link rel="icon" href="https://i.ibb.co/RD7XwYH/pet-logo.png" type="image/png">
    </head>
    <body class="oldschool">
        <header>
    <nav class="oldschoolnav">
        <ul class="listaNavegacao">
            <li>
                <a href="index" style="text-decoration:none;">./Home</a>
            </li>
            <li>
                <a href="licoes" style="text-decoration:none;">Lições</a>
            </li> 
            <li>
                <a href="sobre" style="text-decoration:none;">Sobre</a>
            </li>
        </ul>
    </nav>
</header>

        <div>
            <main>
                
<h1 id="1ᵒ-dia-linux">1ᵒ Dia (Linux)</h1>

<p>Atualmente, os computadores estão em todos os lugares, desde pequenos relógios até gigantescos data centers, conectando tudo entre eles. Nesses computadores, temos a presença de um <strong>Sistema Operacional</strong>, que serve como um mediador do <em>hardware</em> e do <em>software</em> do computador. Os sistemas operacionais mais conhecidos são o Windows, o MacOS e o sistema que trataremos sobre no curso (que não é exatamente um sistema por si só, como você verá depois): o <strong>Linux</strong>.</p>

<p>Como programadores ou aspirantes, é essencial que tenhamos autocontrole sobre os softwares que construimos, as ferramentas que usamos e o ambiente em que trabalhamos, e é nisso que entra o Linux. O Linux como projeto de software é um dos mais ricos ecossistemas que nasceram do esforço coletivo de desenvolvedores do mundo inteiro, com um objetivo em comum: um Sistema Operacional onde o usuário possui liberdade total.</p>

<h2 id="o-que-é-o-linux">O que é o Linux?</h2>
<p>Como dito antes, o Linux não é um sistema operacional por si só, mas sim o que chamamos de um <strong>kernel</strong>, que num sentido mais literal representa um programa que controla os recursos do computador, permite que os usuários rodem programas, controlem os periféricos controlados e, também, provê um sistema de arquivos que gerencia o armazenamento a longo prazo de informação, como programas, dados e documentos.</p>

<p>Num sentido um pouco mais amplo, quando falamos “Linux”, nos referimos a um combo chamado “GNU/Linux”, onde “GNU” (<strong>G</strong>NU is <strong>N</strong>ot <strong>U</strong>nix; mais sobre o UNIX depois) é uma camada superficial do programa que corresponde a compiladores, editores de texto, programas etc.</p>

<p>Num sentido ainda mais amplo, quando falamos “GNU/Linux” ou apenas “Linux”, falamos de uma família de sistemas os quais implementaram essa “interface” por assim dizer. Cada membro da familia é o que chamamos de distro Linux (mais sobre isso no futuro), que agora, de fato, é um sistema operacional completo, pois empacota o que é oferecido pelo Linux e GNU, e torna seu sistema utilizável sem que você tenha que compilar todas as dependências e montar seu sistema do absoluto zero.</p>

<p>Esses detalhes não são realmente importantes para esse curso, pois o nosso objetivo é apenas ensinar como se localizar, investigar e usar diversas ferramentas que são genéricas a uma família ainda maior de sistemas, chamados de “Unix-like”, onde um dos herdeiros dessa família é o Linux.</p>

<h2 id="o-que-é-um-unix-e-o-que-são-os-unix-like">O que é um Unix e o que são os “Unix-Like”?</h2>

<p>Inicialmente, vamos falar um pouco sobre quem começou essa gigantesca família de sistemas chamadas Unix-Like. Era uma vez o Unix, um sistema operacional que foi desenvolvido no início dos anos 1970 como uma alternativa flexível e portátil aos sistemas da época, que eram grandes, caros e difíceis de manter, especialmente porque eram programados em linguagem de máquina específica para cada tipo de hardware. Sendo um dos primeiros sistemas operacionais escritos na linguagem C — possivelmente o primeiro —, o Unix se destacou pela adaptabilidade e facilidade de implementação em diferentes tipos de hardware. Apesar de ser um ótimo sistema para a época, o Unix foi construido para propósitos educaionais e sua licensa era muito cara, talvez por esse motivo ele não tenha sido muito atrativo para a população geral. Independentemente disso, ele trouxe inovações que estabeleceram um modelo e uma filosofia de desenvolvimento de software que ainda influencia inúmeras outras plataformas e sistemas operacionais subsequentes, como o MacOS, sistemas BSDs e os Linux. Esse conjunto de inovações e filosofia, futuramente estabeleceu até um padrão, que é o que chamamos de POSIX.</p>

<h2 id="distros">Distros</h2>

<p>Como foi dito anteriormente, Linux é apenas uma família de sistemas, e cada sistema é chamado de distro Linux. Existem uma série de diferenças entre essas distros, que dependem da implementação de quem os gerencia. Além disso, pelo GNU e o Linux serem “software livre” qualquer uso e implementação do Kernel Linux e do projeto GNU tem que ser gratuita e código aberto. Mas então, qual é a principal diferença entre essas distribuições?</p>

<p>As distros são coleções de software que incluem o kernel Linux, software GNU e, muitas vezes, outros pacotes que podem ser de outras origens. Estas distribuições são adaptadas para atender a diferentes tipos de usuários e podem incluir desde versões muito leves para hardware antigo até sistemas completamente equipados para uso corporativo. Algumas das mais populares são <a href="https://ubuntu.com/desktop">Ubuntu</a>, <a href="https://linuxmint.com/">Mint</a>, <a href="https://fedoraproject.org/">Fedora</a>, <a href="https://www.debian.org/index.pt.html">Debian</a> e <a href="https://archlinux.org/">Arch</a>, cada uma oferece uma experiência de usuário diferente, ferramentas específicas e um sistema de gerenciador de pacotes que facilita a instalação e a manutenção de software.</p>

<h3 id="outros-sistemas-unix-like-bsds">Outros sistemas Unix-Like: BSD’s</h3>

<p>Ao lado das distribuições Linux, existem os sistemas operacionais <a href="https://pt.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a>, que são outra família de sistemas Unix-like. BSD, que significa Berkeley Software Distribution, refere-se a uma série de distribuições de software que foram originalmente desenvolvidas e distribuídas pela Universidade da Califórnia em Berkeley. Assim como o Linux, os sistemas BSD têm um núcleo e ferramentas de usuário, mas são desenvolvidos e licenciados de maneira diferente. Exemplos notáveis de sistemas BSD incluem <a href="https://www.freebsd.org/">FreeBSD</a>, <a href="https://www.netbsd.org/">NetBSD</a> e <a href="https://www.openbsd.org/">OpenBSD</a>.</p>

<p>Os sistemas BSD e as distribuições Linux compartilham muitas das filosofias básicas de sistemas Unix-like, mas cada família tem suas próprias comunidades, filosofias de desenvolvimento, e escolhas técnicas que os diferenciam significativamente.</p>

<h2 id="se-aprofundando-nos-unix-like-um-pouco-sobre-o-shell">Se aprofundando nos Unix-Like: Um pouco sobre o Shell</h2>

<p>Note que nós temos um material inteiro apenas relacionado ao Shell, porém existem alguns conceitos inseparáveis entre o Shell e os sistemas Unix-Like que precisam ser abordados antes disso.</p>

<p>Para entender um pouco melhor do que se trata o shell, note que na época em que o Unix se popularizou (final da década de 70 e início da de 80) não existia uma interface gráfica (GUI) e toda interação era feita via comandos com a ajuda de um terminal. Os caracteres inseridos no teclado eram enviados ao hardware, que enviava uma instrução ao software para que eles aparecessem na tela e o usuário pudesse ver o que estava digitando.</p>

<div style="text-align: center;">
<img alt="Imagem de um DEC VT100 rodando Unix" src="https://hackmd.io/_uploads/HkxmAtRVR.jpg" width="80%" />
</div>

<ul>
  <li><em>Imagem de um DEC VT100 rodando Unix (1978), fonte: <a href="https://en.wikipedia.org/wiki/VT100">https://en.wikipedia.org/wiki/VT100</a></em></li>
</ul>

<p>Essa linha de comando e interface de texto na época era única e exclusiva responsabilidade do Shell, que em síntese é um programa que interpreta a entrada do usuário e a repassa para o sistema, fazendo com que este gerencie o processo (comando) executado.</p>

<p>Atualmente, com o advento das interfaces gráficas, o Shell perdeu muito do seu papel de protagonista e hoje pode ser invocado a partir de o que chamamos de emulador de terminal. Entretanto, caso tenha resolvido não instalar e configurar uma interface gráfica (ao instalar o Arch, por exemplo), o Shell será seu único companheiro.</p>

<div style="text-align: center;">
<img alt="Imagem do emulador gnome-terminal rodando no ubuntu 24.04 LTS" src="https://hackmd.io/_uploads/BkL7RK04A.png" width="80%" />
</div>

<ul>
  <li><em>Imagem do emulador gnome-terminal rodando no ubuntu 24.04 LTS, fonte: <a href="https://canaltech.com.br/linux/ubuntu-2404-lts-e-liberado-veja-as-principais-novidades-286919/">https://canaltech.com.br/linux/ubuntu-2404-lts-e-liberado-veja-as-principais-novidades-286919/</a></em></li>
</ul>

<p>A maioria das distros linux vêm com o shell do projeto GNU, <strong>B</strong>ourne <strong>A</strong>gain <strong>Sh</strong>ell (Bash) pré instalado, não é um padrão e se você quiser, existem diversos outros que você pode instalar e utilizar. Quando o shell é iniciado, o usuário se depara com uma tela do seguinte tipo:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<p>Vamos entender o que significa cada símbolo desse.</p>

<div class="markdown_terminal">
```sh
[user@hostname ~]$
  ^      ^     ^ ^
  │      │     │ └─ O cifrão diz que você não é o usuário `root` (mais sobre isso depois)
  │      │     └── Seu «Working Directory», o diretório que o shell está operando no momento
  │      └── Nome do computador, também conhecido como o nome do host
  └── Nome do usuário que está usando o shell nessa sessão 
``````sh
[user@hostname ~]$
  ^      ^     ^ ^
  │      │     │ └─ O cifrão diz que você não é o usuário `root` (mais sobre isso depois)
  │      │     └── Seu «Working Directory», o diretório que o shell está operando no momento
  │      └── Nome do computador, também conhecido como o nome do host
  └── Nome do usuário que está usando o shell nessa sessão 
```
</div>

<p>A maneira mais simples de usar o shell, é digitando comandos!.</p>

<h2 id="comandos-e-argumentos">Comandos e argumentos</h2>

<p>Os comandos escritos no shell quase sempre precisam vir junto de um <strong>argumento</strong>. Nesse sentido, no shell é necessário muito cuidado no uso de espaços, pois eles são reservados a função de separar argumentos. Por exemplo, ao digitar <code class="language-plaintext highlighter-rouge">tudo bem?</code> em um terminal, a interpretação que o sistema fará é que você está tentando executar o comando <code class="language-plaintext highlighter-rouge">tudo</code> com o argumento <code class="language-plaintext highlighter-rouge">bem?</code>, o que resultará em erro. Os argumentos podem ser o nome de uma pasta, de um arquivo ou até coisas especiais que veremos mais para a frente na aula, como <strong>operadores lógicos</strong> e <strong>flags</strong>.</p>

<p><strong>Veja alguns comandos:</strong></p>

<ul>
  <li>Sem muitas surpresas o comando <code class="language-plaintext highlighter-rouge">date</code> diz o dia de hoje.</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user@hostname ~]<span class="nv">$ </span><span class="nb">date
</span>Sat Jun  1 06:53:57 PM <span class="nt">-03</span> 2024
<span class="o">[</span>user@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<ul>
  <li>E o comando <code class="language-plaintext highlighter-rouge">cal</code> mostra o calendário:</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user@hostname ~]<span class="nv">$ </span>cal
      June 2024     
Su Mo Tul We Th Fr Sa
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30                  
<span class="o">[</span>user@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<ul>
  <li>Tente também o <code class="language-plaintext highlighter-rouge">echo</code>, que repete o argumento com o qual você chamou o comando (fazendo um eco).</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user@hostname ~]<span class="nv">$ </span><span class="nb">echo </span>lfjdslkfdjlsafkds
lfjdslkfdjlsafkds

<span class="o">[</span>user@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<h2 id="histórico-de-comandos">Histórico de comandos</h2>

<p>Se você pressionar <code class="language-plaintext highlighter-rouge">↑</code>, o nosso comando <code class="language-plaintext highlighter-rouge">ablueblauebluebalbbeu</code> vai reaparecer para podermos usa-lo novamente, se você continuar pressionan. Isso é chamado de histórico de comandos e a maioria das distribuições Linux armazenam por padrão pelo menos os últimos 1000 comandos. Se você pressionar <code class="language-plaintext highlighter-rouge">↓</code>, você avança para o presente no histórico até o comando desaparecer.</p>

<p>Agora que aprendemos o básico sobre comandos, vamos entender um pouco sobre o Sistema de Arquivos do Linux e como navegar por ele usando o shell.</p>

<h1 id="entendendo-o-sistema-de-arquivos">Entendendo o Sistema de Arquivos</h1>

<p>Que nem o Windows, um Unix-Like organiza seus arquivos no que é chamado de Estrutura de dirétorios hierárquica. Isso significa que é possível visualizar esse sistema como uma árvore de diretórios, também chamados de pastas. Esses diretórios funcionam exatamente como pastas de escritório que você pode ter em casa, onde cada uma pode ter outra pasta e/ou um arquivo, onde cada arquivo tem um nome, junto com informações extras como a quem ele pertence ou o quão grande ele é.</p>

<p>A principal diferença filosófica entre o sistema de arquivos fundado pelo Unix é que, ao contrário do Windows, que tem um arvóre de arquivos diferente para cada dispositivo de armazenamento, um Unix-like tem apenas uma árvore, que independe da quantidade de dispositivos de armazenamento conectados ao computador.</p>

<p>Além disso, vale ressaltar, que o sistema de arquivos não é capaz de diferenciar entre tipos diferentes de arquivo, ele não impõe nenhuma estrutura a ser seguida por esses arquivos, o significado dos bytes que ali estão sendo armazenados dependem única e exclusivamente dos programas que lidam e interpretam com esse arquivo. Isso não é apenas verdade para arquivos genéricos, mas também para caracteres digitados no seu teclado, dispositivos conectados e tudo que você pode imaginar.</p>

<h2 id="current-working-directory">Current working directory</h2>

<p>O sistema de arquivos funciona como uma árvore: você possui um diretório de origem, o <code class="language-plaintext highlighter-rouge">/</code> (chamado de <strong>root</strong>) e os galhos acima dele, que são os outros diretórios do computador. A partir de um diretório, é possível ver os diretórios diretamente ligados a ele seja “descendo” ou “subindo” a árvore. Quando você acessa um diretório e passa a ter acesso a todos os arquivos dentro dele, aquele passa a ser seu <strong>Working Directory</strong></p>

<div style="text-align: center;">
<img alt="Imagem exemplo de um sistema de arquivos do Linunx" src="https://hackmd.io/_uploads/B15voEO80.png" width="80%" />
</div>
<p><br /></p>

<p>Utilizando o comando <code class="language-plaintext highlighter-rouge">pwd</code>, que é uma sigla para <strong>P</strong>ath to <strong>W</strong>orking <strong>D</strong>irectory, é possível saber o caminho de todos os diretórios da root até o seu diretório atual:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>eu@hostname ~]<span class="nv">$ </span><span class="nb">pwd</span>
/home/eu
</code></pre></div></div>

<p>Além do working directory nós temos também o home directory, que é o único lugar que usuários comuns são autorizados a escrever em ou um arquivo. Para cada usuário é dado um home directory, ou seja por padrão você apenas capaz de ver outros diretórios além do seu, se quiser editar algo que não é seu, você precisará de algo que chamamos de permissões de superusuário, ou sudo (mais sobre isso no futuro).</p>

<h1 id="utilizando-comandos-e-navegando-pelo-sistema-de-arquivos">Utilizando comandos e navegando pelo Sistema de Arquivos</h1>

<h2 id="caminhos-absolutos-e-caminhos-relativos">Caminhos absolutos e caminhos relativos</h2>

<p>Ao navegar pelo sistema utilizando o shell, geralmente utilizamos caminhos absolutos como o do exemplo anterior. Estando no diretório <code class="language-plaintext highlighter-rouge">/home</code>, você pode utilizar o comando <code class="language-plaintext highlighter-rouge">cd</code> (que significa Change Directory) para acessar o diretório <code class="language-plaintext highlighter-rouge">/eu</code>, da seguinte forma:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Perceba o primeiro nome mudando!</span>
<span class="c"># V</span>
<span class="o">[</span>user@hostname ~]<span class="nv">$ </span><span class="nb">cd </span>eu
<span class="o">[</span>eu@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<p>Porém, digamos que você está na pasta <code class="language-plaintext highlighter-rouge">/downloads</code> e deseja ir até a pasta <code class="language-plaintext highlighter-rouge">/escola</code> ! Para isso, é necessário se utilizar do <strong>caminho relativo</strong> <code class="language-plaintext highlighter-rouge">..</code></p>

<p>Os dois pontos representam o <strong>diretório anterior</strong> de forma relativa, e podem ser utilizados para <em>voltar</em> enquanto navegando pelo sistema de arquivos:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>downloads@hostnname ~]<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="o">[</span>eu@hostname ~]<span class="nv">$ </span><span class="nb">cd </span>escola
<span class="o">[</span>escola@hostname ~]<span class="err">$</span>
</code></pre></div></div>
<p>Também temos o caminho relativo <code class="language-plaintext highlighter-rouge">.</code> que representa o <strong>diretório atual</strong>. Na parte de navegação de arquivos esse caminho não é tão interessante, mas é crucial quando estamos tratando de <strong>executar comandos</strong>.</p>

<h2 id="mexendo-nos-diretórios">Mexendo nos diretórios</h2>

<p>Podemos manipular diretórios e arquivos a partir de comandos:</p>

<p>Usando o comando <code class="language-plaintext highlighter-rouge">mkdir</code> (de Make Directory), é possível criar uma nova pasta. A sintaxe do comando é: <code class="language-plaintext highlighter-rouge">mkdir &lt;nome_da_pasta&gt;</code>. Digamos que você acabou de criar na pasta <code class="language-plaintext highlighter-rouge">/escola</code> a pasta <code class="language-plaintext highlighter-rouge">/minicurso_linux_git</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>escola@hostname ~]<span class="nv">$ </span><span class="nb">mkdir </span>minicurso_linux_git
<span class="o">[</span>escola@hostname ~]<span class="nv">$ </span><span class="nb">cd </span>minicurso_linux_git
<span class="o">[</span>minicurso_linux_git@hostname ~]<span class="err">$</span>
</code></pre></div></div>

<p>Você criou essa pasta assim que chegou em casa, logo após a primeira aula do minicurso. Você colocou na pasta um arquivo de texto com as anotações da aula e um arquivo de imagem, com uma <em>selfie</em> que você tirou com um colega no dia da aula. Um tempo se passou, você já se formou na faculdade e você encontra esse diretório novamente, você se pergunta, qual o conteúdo dele?</p>

<p>Com o comando <code class="language-plaintext highlighter-rouge">ls</code>, é possível listar todo o conteúdo de um diretório:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>minicurso_linux_git@hostname ~]<span class="nv">$ </span><span class="nb">ls
</span>anotacoes.txt  selfie.jpg
</code></pre></div></div>

<p>Porém, você está trocando de computador e o computador no qual essa pasta foi criada não será mais utilizado. Ainda muito saudoso pelo seu tempo de novato nesse mundo do Linux, você decide levar o conteúdo dessa pasta para o seu novo computador. Você move os arquivos para um <em>pen-drive</em>, deixando a pasta agora vazia, e então decide removê-la, utilizando o comando <code class="language-plaintext highlighter-rouge">rmdir</code> (note que o comando só funciona se a pasta estiver vazia):</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>minicurso_linux_git@hostname ~]<span class="nv">$ </span><span class="nb">cd</span> ..
<span class="o">[</span>escola@hostname ~]<span class="nv">$ </span><span class="nb">rmdir </span>minicurso_linux_git
</code></pre></div></div>

<p>E… pronto! A pasta agora não existe mais no computador, e você está pronto para iniciar um novo ciclo.</p>

<p>Agora que começamos a ver todos esses comandos, provavelmente uma dúvida veio à sua mente: e se eu precisar utilizar um comando que eu não sei ainda o que faz?</p>

<h2 id="como-investigar-comandos">Como investigar comandos</h2>

<p>O Linux vem com ferramentas que podem ser utilizadas quando se quer saber mais sobre um comando, sem ter que ficar pesquisando na internet toda hora. Usando o comando <code class="language-plaintext highlighter-rouge">man</code>, é possível ver o manual de um comando. Até para comandos mais simples, há uma quantidade absurda de informação, mas não se desespere, vamos dar uma olhada em cada parte do manual:</p>

<div style="text-align: center;">
<img alt="Uma explicação sobre o que mostra o comando 'man'" src="https://hackmd.io/_uploads/ryhfmIdUR.png" width="80%" />
</div>
<p><br /></p>

<p>O manual de um comando tem tudo que é necessário para se entender como um comando funciona e como ele pode se utilizado. Com o conhecimento adquirido até agora, podemos entender perfeitamente as seções vermelha e verde da imagem, mas a seção azul pode ser um pouco confusa, pois mostra todas as <strong>flags</strong> que podem ser utilizadas com o comando.</p>

<h2 id="argumentos-de-comando-flags">Argumentos de comando: flags</h2>

<p>As flags são um tipo de argumento que podem ser utilizadas quando invocamos um comando e que muda diretamente a forma como aquele comando se comporta.</p>


                <section>
    <h1> Dias e Temas </h1>
    <div class="dias_e_temas">
        <ul>
            <li> 1º dia : <a href="primeiroDia">Unix e Linux</a></li>
        
            <li>  2º dia  : <a href="segundoDia"> Linux e shell</a></li>
            <li>  3º dia : <a href="terceiroDia"> Linux e git</a></li>
       
            <li>  4º dia : <a href="quartoDia"> git: branch</a></li>
            <li>  5º dia : <a href="quintoDia"> git: branch</a></li>
        </ul>
    </div>
</section>
            </main>
        </div>
    </body>
</html>
